# tateyama における request/response のデザイン

2022-04-28 arakawa (NT)

## この文書について

* Tateyama の request/response について、トランスポート層、サービス層のそれぞれからどういう概念で取り扱うかについてまとめたもの

## 基本的な考え方

* サービスを制御するための全ての操作は request/response 方式で行う
  * request をサービスに一つ送ると、それに対応する response がちょうど一つ返ってくる
* 便宜上、アーキテクチャを以下のように抽象的に分解する
  * サービススタブ
    * クライアント側で、特定サービスに依存するプログラム
    * 特定のサービスに関するメッセージの授受を行う
    * `DatastoreClient` など
  * クライアントトランスポート
    * クライアント側で、フレームワーク部分 (特定サービス非依存) のプログラム
    * サービススタブから受け取ったメッセージをサーバートランスポートに引き渡す
    * `IpcWire` など
  * サーバートランスポート
    * サーバー側で、サービス非固有のプログラム
    * クライアントトランスポートから受け取ったメッセージをカプセル化し、 **カプセル化リクエスト** として宛先サービスに引き渡す
    * 同時に、サービスにはレスポンスの受け取りをカプセル化した、 **カプセル化レスポンス** も併せて引き渡す
    * `ipc_endpoint` など
  * サービス本体
    * サーバー側にある、サービス本体のプログラム
    * サーバートランスポートから **カプセル化リクエスト** を受け取り、 **カプセル化レスポンス** に結果を挿入する
    * `datastore_service` など
* サービス利用者は、サービススタブを操作することで、サービス本体の機能を利用できる
  * サービススタブ - クライアントトランスポート - サーバートランスポート - サービス本体 の経路で、サービススタブとサービス本体の間でメッセージを授受する
  * この間のメッセージの授受は、先に挙げたように request/response 方式で行う
* トランスポートは、サービススタブとサービス本体の間で授受されるメッセージの形式を知らない
  * tateyama は拡張可能なサービス指向アーキテクチャを採用しており、トランスポートはサービス固有のメッセージを知らず、トランスポート上は単なるバイト列として扱う必要がある
  * サービススタブと、対応するサービス間はお互いを認識しているため、特定形式のバイト列を授受すれば、そこから必要な情報を取り出せる
* サービスは、トランスポートの詳細を知らない
  * tateyama はエンドポイントをサービスと独立しているため、トランスポート内で具体的にどのような内容のメッセージが授受されているかを知りえない
  * その代わり、サービスはカプセル化された request/response をトランスポートから受け取り、そこから必要な情報、機能を利用できる
* request は比較的小さな (~2MB程度) データを取り扱う
  * 巨大なデータを送付する場合、既定のトランスポートとは異なる経路で送る必要がある
    * TBD
  * 現在のところ、BLOBデータ等を想定している
* response は、巨大なデータを非同期に送るため、以下のような構造を取る
  * 主レスポンス
    * 小さな (最大で~2MB程度) のメッセージで、 request ごとにちょうど一つだけ存在する
    * 主レスポンスは必ず **全ての request 処理が完了後** に届けられる
      * つまり、対偶を取ると、主レスポンスが受け取れたら request は完了している
  * 副レスポンス
    * サイズに制限のないデータを取り扱い、 request ごとに0個以上存在できる
    * それぞれの副レスポンスのデータは内部でブロック化可能で、当該データがサービス本体側ですべてそろっていなくても、サービススタブはブロック単位で受け取ることができる
      * 主に、 SQL の result set など、巨大なデータをストリーミング方式で受信することを目的としている
      * 逆に、主レスポンスはブロック化できず、全てのデータがそろうまでサービススタブは利用できない
    * サービスが利用する副レスポンスの一覧が確定したのちに、それぞれの副レスポンスを利用できる
      * つまり、動的に副レスポンスを追加することは想定しておらず、サービスは副レスポンスを作成し始める前にすべての副レスポンスを列挙しなければならない
    * 全ての副レスポンスが完成後に、主レスポンスが完成することになる

## カプセル化された request/response

* カプセル化された request/response は、サーバートランスポートからサービス本体に渡され、サービス本体内で利用できる
  * これらの目的は、トランスポートの詳細をサービス本体から隠蔽しつつ、サービス本体が必要な情報、機能を利用するため
* カプセル化リクエストは、主に以下の機能・情報を提供する
  * サービススタブから送られたメッセージのバイト列
    * サービス本体は、このバイト列を解析し、サービス利用者がサービススタブ経由で依頼した内容の詳細情報を得る
  * サービススタブから送られた添付データ (TBD)
    * リクエストに付随するデータで、サービススタブからリクエストに併せて送られる
    * BLOB データなどを想定
  * 統合管理基盤を利用するための機能または情報
    * サービス利用者のロール情報や、それに伴う認可情報を得るため、カプセル化リクエストから以下のいずれかが必要
      * 統合管理基盤の認証機能を利用するための認証情報
      * または、統合管理基盤の認証済みクライアント
  * 現在のセッションを特定するための情報
    * 現在のアーキテクチャでは、セッション単位でリソースの有効期限を設定しているため、現在のセッションを特定するための情報が必要
    * 端的に言えば `uint64 session_id`
  * リクエストの宛先サービスを特定するための情報
    * これは、メッセージをルーティングするための仕組みが利用するため、そちら側で必要
      * ルーティングを行うのも一つのサービスとしているため、この情報がカプセル化リクエスト上に必要
    * 端的に言えば `uint64 service_id`
* カプセル化レスポンスは、主に以下の機能・情報を提供する
  * 主レスポンスを出力するため機能
    * サービスは、カプセル化レスポンスを通してサービスの結果や、またはエラー情報をサービススタブに返礼する
  * 副レスポンスを出力するための機能
  * 利用する副レスポンスの識別子と個数を通達するための機能
  * フレームワーク上のエラーを通知するための機能
    * サービスは、主レスポンスの代わりにフレームワーク上の標準的なエラーをサービス利用者に通知することができる
      * 主レスポンスと、等例外情報を同時に返礼することはできず、いずれか一つを選ばなければならない
    * 当該機能は、サーバトランスポート内のルーティングを行う機能も利用する
    * 当機能を利用して通知したエラーは、クライアントトランスポート内で処理され、サービススタブをバイパスして利用者に届けられる

## トランスポート上の request/response

* **注意点**
  * 前提として、トランスポートはサービス本体にカプセル化したリクエストとレスポンスを渡し、それがインターフェースの契約に従っている限り、どのような実装でもよい
  * トランスポートごとに詳細は異なるが、ここでは IPC のトランスポートを例に説明する
* リクエストの流れ
  1. サービス利用は、サービススタブを通してサービスを操作する
  2. サービススタブは、操作の内容をシリアライズし、そのバイト列と対象のサービスIDをクライアントトランスポートに渡す
  3. クライアントトランスポートは、サービスIDを含むリクエストヘッダと、操作内容をシリアライズしたバイト列からなるリクエストボディの組を、サーバートランスポートに渡す
  4. サーバートランスポートは、リクエストヘッダの内容を抽出し、それと現在のセッション上の情報やリクエストボディのバイト列を組み合わせてカプセル化リクエストを構築する
     * このタイミングで、認証情報の真正性確認なども行う
  5. サーバートランスポートは、レスポンス用の領域を確保しそれをもとにカプセル化レスポンスを構築する
  6. サーバートランスポートは、レスポンス用の領域をハンドル化してクライアントトランスポートに返す
  7. サーバートランスポートは、カプセル化リクエストとカプセル化レスポンスをルーティングサービスに引き渡す
  8. ルーティングサービスは、カプセル化リクエストから宛先サービスを判別し、カプセル化リクエストとカプセル化レスポンスを宛先サービスに転送する
  9. サービス本体は、カプセル化リクエストから操作内容のバイト列を取り出し、それをデシリアライズして要求された操作を行う
* レスポンスの流れ
  1. サービス本体は、必要な副レスポンスの個数と、それぞれの名前をカプセル化レスポンスに通知する
      1. サーバートランスポートは、カプセル化レスポンスを介して副レスポンスの情報を受け取り、対応する副レスポンスの領域を確保してサービス本体に通知する
      2. サーバートランスポートは、作成した副レスポンスの識別子と領域へのハンドルを、クライアントトランスポートに通知する (=レスポンスヘッダ)
      3. クライアントトランスポートは、副レスポンスの識別子と領域へのハンドルをカプセル化し、サービススタブに届ける
      4. サービススタブは、カプセル化した副レスポンスからサービス本体のデータを受け取り、デシリアライズしてサービス利用者に届ける
  2. サービス本体は、サービス利用者が要求した操作を行い、必要に応じて各副レスポンスにデータを追記する
      * 副レスポンスに追記されたデータは、前述と同様の方法でサービス利用者に届けられる
  3. サービス本体は、要求された操作が完了後、カプセル化レスポンスを通して結果を通知する
      * 操作が正常終了した場合 (サービス固有のエラーも含む)
        1. サービス本体は、カプセル化レスポンスを通して主レスポンスに結果をシリアライズしたバイト列を書き込む
        2. サーバートランスポートは、主レスポンスがサービス本体からの結果であることを表す主レスポンスヘッダと、シリアライズしたバイト列からなる主レスポンスボディの組をクライアントトランスポートに渡す
        3. クライアントトランスポートは、主レスポンスヘッダにサービス本体からの結果であるという情報を確認したのち、主レスポンスボディのバイト列をサービススタブに引き渡す
        4. サービススタブは、主レスポンスボディのバイト列をデシリアライズし、処理の結果としてサービス利用者に届ける
      * 操作がエラー終了した場合 (フレームワーク上のエラー)
        1. サービス本体は、カプセル化レスポンスを通してエラーを通知する
        2. サーバートランスポートは、主レスポンスがフレームワークエラーであることを表す主レスポンスヘッダと、エラー情報をシリアライズしたバイト列からなる主レスポンスボディの組をクライアントトランスポートに渡す
        3. クライアントトランスポートは、主レスポンスヘッダにフレームワークエラーという情報を確認したのち、主レスポンスボディのバイト列をデシリアライズして、サービススタブにエラーを通知する
        4. サービススタブは、通知されたエラーをサービス利用者に届ける
* なお、サービスの処理が始まる以前にエラーが発生した場合などには、「操作がエラー終了した場合 (フレームワーク上のエラー)」と同等の経路でエラーを通知する

### IPC における request/response のメッセージ形式例

* request

  ```proto
  // common service request header.
  message Header {
      reserved 1 to 10;

      // the current session ID.
      uint64 session_id = 11;

      // the destination service ID.
      uint64 service_id = 12;
  }
  ```

* response

  ```proto
  // the response header.
  message Header {
      reserved 1 to 10;

      // individual attached data information.
      message SubResponse {
          // the sub-response ID.
          string id = 1;

          // the sub-response locator.
          string location = 2;
      };

      // the sub-response list.
      repeated SubResponse sub_responses = 12;
  }

  // the header of main response part.
  message MainHeader {

      // the content type of the main response body.
      enum BodyType {
          // unknown response (may be response is broken).
          UNKNOWN = 0;

          // server diagnostic type (tateyama.proto.diagnostics.Record).
          SERVER_DIAGNOSTICS = 1;

          // the requested service result.
          SERVICE_RESULT = 2;
      };

      // the content type of the main response body.
      BodyType body_type = 11;
  }
  ```
