# IPC通信ベンチマーク

2023-04-12 ohkubo (NT)

## この文書について
IPC通信ベンチマークの内容と使い方を解説する。

## ベンチマーク概要
本ベンチマークは、IPC通信の基本的な通信処理について、ベーススコアを調査するためのものである。
２つの主要経路を調査するため、以下のベンチマークがある。

- ``reqres_loop``: request/response経路について、往復通信などの通信性能を調査する。
- ``data_channel_write``: resultsetの通信経路であるdata_channel経路について、送信処理の性能を調査する。

## ビルド方法
- ``-DBUILD_BENCHMARK=ON`` 指定でビルドする。デフォルトで``ON``になっている。
  - ベンチマークのビルドが不要の場合は、``-DBUILD_BENCHMARK=OFF`` とする。
  - tateyama 自体のビルド方法は、tateyama/README.md などを参照。

- データベースは利用しないので、``-DSHARKSFIN_IMPLEMENTATION=memory`` 指定でビルドしてもよい。
- ベンチマークであるので、``-DCMAKE_BUILD_TYPE=Release`` 指定でビルドするとよい。

## ベンチマーク実行について
### 実行バイナリのパス
- 標準的なビルド方法に従うと、ベンチマークの実行バイナリは以下になる。
  - ``build/bench/reqres_loop/reqres_loop``
  - ``build/bench/data_channel_write/data_channel_write``
- ビルドディレクトリを``build``以外にした場合は、上記を適宜読み替えること。
- ベンチマークプログラムの起動ディレクトリはどこでも良い。

### 実行環境について
- サーバーの起動環境や設定ファイルの準備は不要である。
  - IPCの接続データベース名・ワーキングディレクトリは、ベンチマーク起動ごとに乱数を含めて自動設定している。
  詳細は、本文書の「関連ファイル」節を参照。
- サーバーやクライアントを前もって起動する必要はない。必要なプロセスはベンチマークプログラムが生成する。

## 実行方法
### reqres_loop
#### 概要
IPCのrequest/response経路について、スループットを計測する。
サーバーは、いわゆるエコーサーバーであり、クライアントが送信したメッセージをそのまま返信する。
クライアントは、指定されたサイズのメッセージ送受信を繰り返す。
なお、調査対象をrequest経路に限定し、要求送受信のみ（応答送受信なし）を繰り返すことも出来る。
セッション数やメッセージサイズ、送信回数などはベンチマーク起動時に指定する。

実行結果は、CSV形式で標準出力に表示される。

#### 実行方法
```
reqres_loop [nsession {mt|mp} msg_len nloop] [{sync|async|nores}] 
```

#### 実行オプション
- *nsession*：生成するセッション数。
- {``mt``|``mp``}：マルチスレッドクライアントかマルチプロセスクライアントかを指定する。
   - ``mt``：1つのクライアントプロセスがセッション数分のスレッドをすべて生成する。
   - ``mp``：1プロセス1セッションとし、クライアントプロセスをセッション数個生成する。
- *msg_len*：送信するメッセージサイズ（バイト）。
  - メッセージヘッダサイズは含まない。
  - ``0``を指定可能である。その場合、メッセージヘッダだけの通信が行われる。
- *nloop*：通信方法が
   - ``sync``, ``async``のとき：メッセージの往復回数（1セッションあたりの送信回数＝2 * *nloop*回）。
   - ``nores``のとき：要求メッセージの送信回数（1セッションあたりの送信回数＝*nloop*回）。
-  {``sync``|``async``|``nores``}：通信方法をいずれかで指定する。無指定の場合は、``sync``とみなす。
   - ``sync``：クライアントは、要求送信と応答受信を同期的に行う。
   クライアントは要求送信をし、サーバーからの応答を受信する。これを単純に繰り返す。
   サーバーでの要求待ちとクライアントでの応答待ちがあるため、CPUの実使用率は50%となる。
    1セッションあたりの使用スレッド数は、サーバー・クライアントに各1つで計2つとなる。
   - ``async``：クライアントは、要求送信と応答受信を非同期に行う。
	 つまり、1つのクライアントは要求送信スレッドと応答受信スレッドの2つを持ち、それぞれが独立して処理を進める。
	 同期的な送受信と違い、サーバーでの要求待ちやクライアントでの応答待ちがないため、スループットが向上する。
	 ただし、1セッションあたりの使用スレッド数が3つになるため、CPUの物理コア数が少ない環境では、性能が頭打ちになるのが早くなる。
   - ``nores``：クライアントはサーバーに要求送信する。サーバーは応答を送信しない。
	 request経路のみの通信速度を調査するため、応答の送受信を行わない。
	 クライアントは待ちなく要求を送信し、サーバーはそれを受信し、読み捨てる。
	 1セッションあたりの使用スレッド数は、``sync``と同じ、2つとなる。
	 
#### オプションの指定例
- ```reqres_loop 4 mt 128 100000```
   - マルチスレッドクライアントで4セッション生成し、セッションごとに128バイトのメッセージを10万回往復する。
   - 通信方法は、無指定のなので``sync``になる。
- ```reqres_loop 4 mt 256 100000 async```
   - マルチスレッドクライアントで4セッション生成し、セッションごとに256バイトのメッセージを10万回往復する。
   - 通信方法は、``async``とする。
- ```reqres_loop 8 mp 1024 100000 nores```
   - マルチプロセスクライアントで8セッション生成し、セッションごとに1024バイトのメッセージを10万回送信する。
   - 通信方法は、``nores``とする。
   
- ```reqres_loop help``` とすると、簡易ヘルプが表示される。
- オプション無し（もしくは通信方法指定のみ）で起動すると、様々なオプション設定でのベンチマークを順に繰り返す。
  - これは開発者向けのベンチマーク兼プロファイリング機能である。利用は推奨しない。
  - 実行されるオプション内容はソースコードを参照すること。
  - 実行中にリソース使用情報なども取得し、ベンチマーク終了時にまとめて表示する。

#### 出力形式
1行のCSVを標準出力に出力する。各カラムは順に以下の値である。

- セッション数。
- {``mt``|``mp``}：クライアントがマルチスレッドかマルチプロセスか。
- {``sync``|``async``|``nores``}：いずれかの通信方法。
- 送信メッセージサイズ（バイト）。
- 繰り返し回数（前述の実行オプションの*nloop*参照）。
- クライアントの送信開始から全クライアントプロセス完了までの経過時間（秒）。精度はマイクロ秒。
  - セッションの確立・破棄の処理時間も含むが、十分小さいとみなして無視する。
- 1秒あたりの総メッセージ送信回数。要求・応答の一往復を2回とカウントすることに注意。
- 1秒あたりの総送信データ量（GB/秒)。

#### 実行例
◆同期往復（``sync``）の例
```
$ build/bench/reqres_loop/reqres_loop 4 mt 128 100000
4,mt,sync,128,100000,0.507651,1575884.389323,0.19
```

- マルチスレッドクライアントで4セッション生成し、セッションごとに128バイトのメッセージを10万回往復した。
- 通信方法は未指定なので``sync``となる。
- 約0.5秒かかり、4セッション合計で1秒あたり約160万回のメッセージ送信（セッションあたり毎秒約20万回往復）、0.19GB/秒のスループットであった。

◆非同期往復（``async``）の例
```
$ build/bench/reqres_loop/reqres_loop 4 mt 128 500000 async
4,mt,async,128,500000,0.565462,7073862.702996,0.84
```
- 上の同期往復とほぼ同様に、非同期で50万回往復した。
- 約0.6秒かかり、4セッション合計で1秒あたり約700万回のメッセージ送信（セッションあたり毎秒約90万回往復）、0.84GB/秒のスループットであった。
- 非同期とすることで、サーバー側・クライアント側の待ち時間がなくなり、スループットが4倍程度向上した。向上の度合いは、使用可能なコア数などの実行環境による。

#### 注意点
- 最大セッション数や送信可能な最大メッセージサイズなどは、他のモジュールの実装依存であり、ベンチマークプログラムではチェックしていない。

### data_channel_write
#### 概要
resultsetのdata_channel経路について、スループットを計測する。
サーバーは指定されたサイズのデータを繰り返し送信する。
クライアントはデータを受信し、読み捨てる。
セッション数やメッセージサイズ、送信回数などはベンチマーク起動時に指定する。

実行結果は、CSV形式で標準出力に表示される。

#### 実行方法
```
data_channel_write [nsession {mt|mp} msg_len nloop] 
```

#### 実行オプション
- *nsession*：生成するセッション数。
- {``mt``|``mp``}：マルチスレッドクライアントかマルチプロセスクライアントかを指定する。
   - ``mt``：1つのクライアントプロセスがセッション数分のスレッドをすべて生成する。
   - ``mp``：1プロセス1セッションとし、クライアントプロセスをセッション数個生成する。
- *msg_len*：送信するメッセージサイズ（バイト）。
  - メッセージヘッダサイズは含まない。
  - ``0``を指定可能である。その場合、メッセージヘッダだけの通信が行われる。
- *nloop*：メッセージの送信回数（1セッションあたりの送信回数＝*nloop*回）。

#### オプションの指定例
- ```data_channel_write 4 mt 128 100000```
   - マルチスレッドクライアントで4セッション生成し、セッションごとに128バイトのメッセージを10万回送信する。
   
- ```data_channel_write help``` とすると、簡易ヘルプが表示される。
- オプション無しで起動すると、様々なオプション設定でのベンチマークを順に繰り返す。
  - これは開発者向けのベンチマーク兼プロファイリング機能である。利用は推奨しない。
  - 実行中にリソース使用情報なども取得し、ベンチマーク終了時にまとめて表示する。

#### 出力形式
1行のCSVを標準出力に出力する。各カラムは順に以下の値である。
前述の``reqres_loop``での通信方法のカラムがないだけで、あとは同じである。

- セッション数。
- {``mt``|``mp``}：クライアントがマルチスレッドかマルチプロセスか。
- 送信メッセージサイズ（バイト）。
- セッションあたりの送信回数。
- クライアントの送信開始から全クライアントプロセス完了までの経過時間（秒）。精度はマイクロ秒。
  - data_channelを準備するための要求・応答送受信処理が、ベンチマークの開始時に1回だけ行われる。その処理時間も含むが、十分小さいとみなして無視する。
- 1秒あたりの総メッセージ送信回数。
- 1秒あたりの総送信データ量（GB/秒)。

#### 実行例
```
$ build/bench/data_channel_write/data_channel_write 4 mt 1024 1000000
4,mt,1024,1000000,0.507837,7876549.516173,7.51
```

- マルチスレッドクライアントで4セッション生成し、セッションごとに1024バイトのメッセージを100万回送信した。
- 約0.5秒かかり、4セッション合計で1秒あたり約788万回のメッセージ送信、7.51GB/秒のスループットであった。

#### 注意点
- 最大セッション数や送信可能な最大メッセージサイズなどは、他のモジュールの実装依存であり、本プログラムではチェックしていない。
- 送信可能な最大メッセージサイズは、現時点では、64*1024 - 4 = 65532バイトである。指定する送信メッセージサイズは、これ以下とすること。

## 関連ファイル
サーバー稼働に必要なファイル・ディレクトリが自動的にランダムな名前で作成される。
通常はベンチマークの終了時にすべて削除されるが、強制停止した場合はそのまま残るので、適宜削除すること。

- ワーキングディレクトリ
  - /tmp/tateyama-test-*xxxxxxxx*/
- 共有メモリファイル：/dev/shm/配下に、起動ごと・セッションごとのファイルが生成される。
    - *xxx...xxx*.stat (*xxx...xxx*は32文字)
    - *xxxx-xxxx-xxxx-xxxx*, *xxxx-xxxx-xxxx-xxxx*-1, *xxxx-xxxx-xxxx-xxxx*-2, ...
- サーバーの起動待ち合わせ用ファイル
  - /tmp/ipc-test-*nnnnn*-*mmmmmmmm*
